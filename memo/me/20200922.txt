@메소드 오버로딩
-> 자바의 메소드 호출에는 메소드명과 매개변수 개수, 타입을 보고 호출할 메소드를 찾는다.
-> 그렇기 때문에 같은 이름의 메소드명이라고 하더라도 매개변수의 개수가 다르거나 타입이 다르다면
    동일한 메소드명으로 제작이 가능하다. (리턴타입은 상관없음 리턴타입만 다르게한다고 오버로딩 성립 안됨)

@생성자(Constructor)와 소멸자
->생성자는 class를 바탕으로 객체가 생성될 때 자동으로 호출되는 메소드
->소멸자는 객체가 소멸할 때 자동으로 호출되는 메소드
->타 언어에서는 생성자와 소멸자가 있지만 java언어 특성상 생성자는 있지만 소멸자는 존재하지 않음
※소멸자가 존재하는 이유 : 타 언어에서는 사용한 메모리에 대한 정리도 개발자가 직접 수행
 (ex. new를 사용하면 프로그램이 종료되기 전 delete를 해주어야 했음)
 하지만 자바라는 언어는 메모리에 대한 정리는 개발자가 직접하지 않는다.
 자바는 JVM을 통해 GC(Garbage Collector)를 운영
 GC는 JVM에서 사용하는 메모리가 꽉차기 전에 자동으로 특정 알고리즘을 통해
 메모리를 자동 정리하는 역할을 해주고 있음
 (즉, 자바는 개발자에게 메모리 관리까지 생각하지말고 개발에만 집중할 수 있도록 하는 개발자 중심 언어)

@생성자
-> 객체가 생성될 때 자동으로 호출되는 메소드(무조건 불러옴)
-> 일반적으로 객체가 제대로 동작할 수 있게 준비하는 역할(기본데이터 입력 등)
-> 메소드 이름은 클래스 이름과 같아야 하며 리턴 값(타입)이 없는 메소드
-> 생성자를 이용하면 객체 생성과 동시에 초기값 대입이 가능함
EX) new ConstructTest(); -> 이런식으로 객체생성을 할 때 ConstructTest뒤에 있는 괄호가 생성자 함수를 호출한 것이다.
package com.kh.ex;

public class ConstructTest {
	ConstructTest(){         -> 매개변수 없이 아무 동작 없는 생성자 Default생성자
		
	}
}
-> 매개변수 없이 아무 동작 없는 생성자 Default생성자
->생성자함수는 개발자가 명시하지 않으면 Default생성자로 생성된다. 하지만 개발자가 한번이라도 명시한다면
Default생성자는 생성되지 않는다. 따라서 생성자를 정의할 때에는 Default생성자를 정의하고 정의하는것을 권장한다.
->생성자함수는 이렇게 명시하지 않아도 묵시적으로 저런식으로 실행되고 있는 것이다.
->따라서 저 생성자 함수는 객체 생성과 동시에 무조건 실행된다.

@생성자 오버로딩
-> 생성자도 메소드다. 따라서 생성자도 오버로딩이 가능하다. 오버로딩 설명은 위에

@지역 전역 정적 변수
-> 우리가 클래스 안에서 생성하는 변수들은 크게 3가지로 나뉨
1. 지역변수 : 해당 지역 안에서만 사용가능한 변수
-> 메소드 혼자서 쓰는 변수 해당 메소드에서 만들어지고 해당 메소드만 쓴다.
2. 전역변수 : 해당 클래스안에서 사용 가능한 변수
->전역변수는 해당 클래스로 객체를 생성할 때 만들어지고 GC에서 폐기할때 같이 패기됨
-> 해당 클래스의 모든 메소드가 공유하는 변수
3. 정적변수 : 클래스와 관계없이 사용 가능한 변수(private로 생성시 실제 생성된 객체끼리 공유 public으로 생성시 어디서든)
-> 해당 클래스로 만든 객체끼리 공유하는 변수(private)
-> 모든 클래스가 서로 공유하는 변수(public)
->static 이라는 키워드가 붙여지면 객체 생성과 상관없이 언제든지 사용할 수 있는 변수
  혹은 메소드가 됨(프로그램 시작과 동시에 만듦)

@final : 상수화 
ex. final int data = 10; 이면 10을 가지고 data라는 이름을 가진 상수가 됨
-> 대신 상수화엔 규칙이 있음 변수명은 무조건 대문자로 적는다.
-> 만들 때에 초기화를 해야함 왜냐면 값이 없는데 상수화를 할 수 없음
※추가 내용
-> 메소드에 final키워드를 붙이게 되면 오버라이딩을 못하게 막는 설정이 된다.
->class에 final키워드를 붙이게 되면 상속을 못하게 막는 설정이 됨

@객체배열
-> 객체를 생성할 때 new라는 연산자를 사용해서 만들게 되는데,
다수의 객체가 필요할 때 객체배열을 통해서 손쉽게 사용하고, 관리할 수 있음

ex. 학생관리를 2명한다고 할 때
[기존]
Student s1 = new Student();
Student s2 = new Student();

[객체 배열]
//이것은 객체를 생성한 것이 아님 객체주소를 저장할 수 있는 레퍼런스 배열을 생성한 것
Student[] stdArr = new Student[2];
stdArr[0] = new Student;
stdArr[1] = new Student;