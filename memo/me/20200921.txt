@메소드의 정의와 호출
-> 메소드는 사용하기 전에 미리 정의를 해놓고 호출한다

Ex 예시
public void callerFunction(){
	calleeFunction();                        ----> 콜러함수 (호출을 하는 함수)
}

public void calleFunction(){
	System.out.println("안녕하세요");    ----> 콜리함수 (호출을 당하는 함수)
}

@메소드의 호출 방식
-> 메소드를 호출할 때 인수(혹은 인자)를 전달하는 방식

전달 방식에 따른 2가지 방식

1. 값에 의한 호출(Call by Value)
-> 인수 값을 호출한 메소드에 전달
-> 원본 값 수정 불가

2. 참조에 의한 호출(Call by Reference)
-> 인수의 주소를 호출한 메소드에 전달
-> 원본 값 수정 가능


@객체지향 프로그래밍이란?
-> 객체라는 것을 중점적으로 두고 프로그래밍 하는 방법을 말함
 (절차지향은 절차를 중점적으로 두고 프로그래밍)

-> 현실세계는 사물이나 개념처럼 독립되고, 구분되는 각각의 객체로 이루어져있음
 이 개념처럼 각각의 독립되는 형태로 구현되어 있는 것이 객체

-> 객체지향 프로그래밍을 하기 위해서는 실제 객체에 대한 분석이 필요함

-> 객체를 표현하는 것에는 속성(데이터)과 기능(메소드)으로 구분한다.

@객체지향 용어
클래스 : 객체를 만들기 위한 설계도 혹은 툴
사물이나 개념의 공통요소(속성, 기능)를 용도에 맞게 추상화 해야 함

추상화 : 프로그램에서 필요한 속성과 기능을 추출하고, 불필요한 것을 제거하는 과정
프로그래밍적으로 보았을 때 속성으로 사용할 것과 기능으로 구현할 것들을 설계하는 과정

※객체를 만들기 위한 작업
대상 선정 -> 추상화 -> 클래스 제작 -> 인스턴스화(객체화)

@객체지향의 3대 원칙
1. 캡슐화
2. 상속
3. 다형성

@접근제어 지시자
-> 클래스안에서 변수 및 메소드 생성시 접근제어 지시자를 사용해야 함
-> 접근제어 키워드는 private, public, protected, default
->접근제어 지시자는 접근할 때 허용 범위를 뜻함
private : 해당 클래스에서만 접근 가능
public : 어디서든 접근 허용
default : 같은 패키지 내, 해당 클래스 내부에서 접근 가능
protected : 후손클래스, 같은클래스 내, 해당클래스 내부에서 접근 가능

private < default < protected < public

@정보은닉
-> 정보를 숨기는 것
##정보 은닉의 필요성
-> 클래스의 멤버변수는 일반적으로 private에 저장
-> 의도치 않은 외부 접근에 대한 오류를 방지하기 위함
-> 클래스를 만든 개발자는 해당 클래스의 멤버 변수를 타 사용자가 마음대로
바꾸게 두어서는 안됨(프로그램 흐름상 문제가 발생할 수 있음)

@캡슐화
-> 하나의 객체는 독립적으로 완벽한 역할을 수행할 수 있어야 한다.
-> 정보은닉+독립적인 역할을 수행하면 캡슐화 작업을 하였다 라고 볼 수 있음

@setter와 getter
->private으로 설정된 멤버 변수들은 외부에서 접근이 불가능함
-> 하지만 실제로 해당 클래스를 객체화해서 사용해야 하는 다른
개발자 입장에서는 멤버변수의 데이터를 대입할 수 있어야함
-> 이 때 메소드는 public으로 만든다 라는 개념을 알고 있기 때문에
메소드를 이요하여 데이터를 넣고, 꺼낼 수 있도록 만들어야 함
->하지만 우리가 멤버변수의 넣고, 꺼내는 메소드명을 제작자(해당클래스 개발자)
마음대로 정한다면 수 많은 혼란이 생길 수 있음
(ex. inputName, inName등)
->이름을 개발자 마음대로 하게 되면 사용자는 코드를 이해할 수 없고,
그 순간 코드를 열어서 분석할 수 밖에 없음(캡슐화가 깨지는 순간임)
->그렇기 떄문에 우리는 멤버변수의 값을 넣거나 꺼낼 때 사용하는 메소드를
만들때에는 get set이라는 키워드를 붙여서 제작

@클래스의 종류
->실행용 클래스(main 메소드를 포함한 클래스)
->정보저장요 클래스(vo 클래스)
->컨트롤용 클래스(vo들을 바탕으로 로직을 구현한 클래스)