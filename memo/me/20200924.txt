@추상 클래스
-> 객체 생성을 막아놓는 클래스
-> public abstract class 클래스명 {}
-> 클래스 안에 추상메도스를 가지고 있으면, 그 클래스는 반드시 추상클래스가 되어야 한다.
-> 추상클래스를 상속받은 후손 클래스는 반드시 부모의 추상메소드를 완성시켜야 되는 강제성이 부여된다.
-> 추상 클래스라고 해서 반드시 추상메소드를 포함하여야 하는 것은 아니다.
-> 후손 클래스는 추상 메소드를 반드시 오버라이드해서 선언해야 한다.

@abstract 키워드
-> public abstract double getInterest(); 
-> 나는 몸체가 없는 메소드입니다.(자식에게 물어봐)
-> 나를 포함한 클래스를 상속한 자식들은 무조건 재정의해야 합니다.
-> 이러한 걸 추상메소드라 한다.
-> 추상메소드를 하나라도 포함한 클래스는 추상클래스이다.
-> 추상클래스를 상속받는 하위 클래스는 부모클래스의 추상메소드를 무조건 오버라이드 해야 한다.
-> 오버라이드하는 메소드는 리턴타입과 메소드명을 동일하게 해야한다.
    리턴타입을 다르게 할 경우 동일메소드라고 취급하지 않는다.

@ '@'가 붙은 문법 예를 들어 @Override 같은 것을 어노테이션이라고 부른다.

@인터페이스(interface)
->상수형 필드와 추상 메소드로만 구성된 추상 클래스의 변형체
->클래스에 추상메소드를 포함시키는 구조보다 메소드의 통일성을 부여하기 위해서 추상메소드만 따로 모아놓은 추상클래스
->인터페이스클래스에서는 어차피 추상메소드만 모아놓는 클래스이기 때문에 abstract 키워드를 생략 가능하다
->인터페이스를 상속 받을 때에는 extends가 아닌 implements 키워드를 쓴다.
ex. public class 클래스명 implements 인터페이스명{}
[public] interface 인터페이스명
{
	//상수형 필드

	//추상 메소드
}
@인터페이스의 사용
-> interface는 implements키워드를 이용하여 사용됨
-> 클래스의 상속 : extends (단일 상속), 인터페이스의 상속 : implements 인터페이스명(다중 상속)
-> 클래스의 상속은 1개만 가능하지만 인터페이스는 다중 상속이 가능함

@문자열 비교
-> 문자열 또한 객체이다. 따라서 String a = "21314"는 String a = new String("21314"); 와 같다.
-> 따라서 위의 예시에서 a는 레퍼런스이다.
-> 따라서 String객체안의 메소드를 사용하여 문자열을 비교한다.
-> a.equals(비교할것)