http://192.168.30.35:8080/

[개발환경세팅]
1. JDK 설치
⊙jdk-8u144-windows-x64
 ->jdk1.8.0_144, jdk1.8.0_144

2. 이클립스 설치(Enterprise 버전:웹도 하기 위해서)
⊙eclipse-inst-win64

3. 

⊙.metadata : 작업공간에 대한 환경설정 데이터들을 보유한 폴더 (지우면 안됨)

⊙JDK(Java Developement Kit) : 자바 언어를 활용하여 자바 프로그램을 제작할 수 있는 도구 (컴파일러를 포함하고 있음)
⊙JRE(Java Runtime Environment) : 자바 언어로 제작된 프로그램을 실행하기 위한 도구
⊙JVM(Java Virtual Machine) : 

⊙IDE(Integrated Developement Environment) : 통합개발환경 ex. Eclipse, Visual Studio 등

⊙이클립스의 뷰 영역 : 파일이나 디렉토리를 개발자가 보기 편하게 구조화해서 보여주는 도구
⊙Project Explorer : 웹 개발에 최적화면 뷰, 추후 자바 웹 개발할 때 많이 사용
⊙Package Explorer : 자바 패키지 형태로 보여주는 뷰, 패키지 형태로 기본 자바에서 많이 사용함
⊙Navigator : 윈도우 탐색기와 비슷한 형태의 뷰, 윈도우 탐색기 모양에 익숙한 개발자가 많이 선호하는 뷰

⊙bin폴더 : 소스파일을 가지고 기계어로 번역된 바이너리 파일이 있는 폴더(이 바이너리 파일을 가지고 JVM이 실행함)
⊙src폴더 : 개발자가 작성한 소스파일이 있는 폴더
 ->따라서 개발자가 src폴더에 소스코드를 생성하여 저장하면 bin폴더에 .class라는 파일로 자동으로 번역되어 저장된다.

●이름 표기 명명규칙
⊙프로젝트명
 ->이클립스의 프로젝트 의미는 하나의 큰 작업이라는 의미
 ->여러개의 패키지가 존재하는 공간
 ->프로젝트명은 낙타표기법을 이용하여 표기(소문자로 시작 구분되는 단어마다 첫글자 대문자)
 ex) javaProject
⊙패키지명 명명규칙
 ->패키지는 프로젝트 안에 존재하는 폴더
 ->패키지 안에 다양한 소스파일들이 존재함
 ->대문자 금지!!,도메인 이름으로 많이 짓는다 
 ex) 네이버 회원관리 패키지라면 -> com.naver.member.control
⊙클래스명 명명규칙
 ->실제 소스코드가 들어있는 파일
 ->첫글자 대문자 구분되는 단어 첫글자 대문자 
 ex) MyNameIs

●메모리 구조
⊙stack : 일반변수와 레퍼런스 변수는 stack메모리에 생성
⊙heap : new연산자를 사용하여 만든 경우 heap메모리에 생성(동적 메모리) heap에 저장되는 변수는 자동으로 0으로 초기화
⊙static : 정적 변수나 메소드는 static메모리에 생성

●배열 -> 동일한 데이터 타입을 가지는 변수들의 집합
⊙배열의 쓰임
->여러 개의 변수를 한번에 선언 가능하며 같은 데이터타입의 변수들을 연속적으로 사용할 수 있다.

⊙배열의 선언
->배열을 사용하기 위해서는 주소값을 저장하기 위한 레퍼런스 변수가 필요하다.
 - 자료형 [] 변수이름; ex. int[] arr;
 - 자료형 변수이름[]; ex. int arr[];   ->여기서 arr를 레버런스 변수라고 한다.

⊙배열의 생성
->배열은 레퍼런스만으로는 사용할 수 없음
->실제 데이터를 저장하기 위한 배열을 만들어야 함
-> 레퍼런스 이름 = new 자료형[저장공간개수] ex. arr = new int[5]; -> 5개의 int형으로 이루어진 공간을 가진 배열의 주소를 arr에 저장한다는 의미

⊙배열의 초기화
1. 초기화 없음 ex) int[] arr = new int[5]; -> 배열은 초기 생성시 초기값을 0을 가지고 있다(int형은 0 / boolean형은 false / char은 ")
2. int [] arr = new int[]{1, 2, 3, 4, 5};
3. int [] arr = {1, 2, 3, 4, 5};
 단, int [] arr = new int[5]{1, 2, 3, 4, 5}; 로 코딩할 경우 에러 발생

⊙배열의 얕은복사
->배열의 레퍼런스는 Stack에 실제 배열은 Heap에 저장됨 따라서 Stack의 레퍼런스는 Heap에 저장된 실제 배열의 주소만을 저장
ex. int[] arr1 = new int[] {1, 2, 3, 4, 5}; stack의 arr은 heap의 {1,2,3,4,5}의 주소만을 저장
  이때 int[] arr2 = arr1 이렇게 할 경우 저 heap의 {1,2,3,4,5}의 주소를 arr2에게도 저장된다. 따라서 하나의 배열공간주소를
  두 개의 레퍼런스 변수가 참조할 수 있게 된다. 이게 얕은복사
  따라서 어떤 하나의 레퍼런스로 배열의 값을 바꿔도 참조하고 있는 모든 레퍼런스에 저장된 배열의 값이 바뀐다.

⊙배열의 깊은복사(arraycopy메소드)
ex. System.arraycopy(arr1, 0, arr2, 0, arr1.length)
    (원천배열, 출발인덱스, 목적배열)
-> 주소값을 복사하는게 아닌 실제 배열의 데이터들을 복사해서 새로운 공간에 넣는다.

⊙나머지 연산자
->나머지 연산자를 이용하면 짝수홀수를 구할수 있다.