

JRE : Java 언어로 제작된 프로그램을 실행하기 위한 도구
JDK : Java 언어를 활용하여 Java 프로그램을 제작할 수 있는 도구
IDE : 통합 개발 환경 / 이클립스, 비쥬얼 스튜디오 같은 도구


* 뷰
-> 파일이나 디렉토리를 개발자가 보기 편하게 구조화해서 보여주는 도구

Project Explorer
-> 웹 개발에 최적화면 뷰
-> 추후 자바 웹 개발할때 많이 사용 함

Package Explorer
-> 자바 패키지 형태로 보여주는 뷰
-> 패키지 형태로 기본 자바에서 많이 사용 함

Navigator
-> 윈도우 탐색기와 비슷한 형태의 뷰
-> 윈도우 탐색기 모양에 익숙한 개발자가 많이 선호하는 뷰






src : 개발자가 작성한 소스파일이 있는 폴더
bin : 소스파일을 가지고 기계어로 번역된 바이너리 파일이 있는 폴더
	(추후 바이너리 파일을 가지고 JVM이 실행 함)

@ 이름 표기법

1. 프로젝트명
-> 이클립스의 프로젝트 의미는 하나의 큰 작업이라는 의미(ex. 쇼핑몰 프로젝트)
-> 여러개의 패키지가 존재하는 공간
-> 프로젝트명은 낙타표기법을 이용하여 표기하며
(소문자로 시작하여 구분하는 단어마다 첫글자는 대문자로 표기함)
ex) javaProject

2. 패키지명
-> 패키지는 프로젝트 안에 존재하는 폴더
-> 패키지 안에 다양한 소스 파일들이 존재함
-> 패키지명은 모두 소문자로 표기하여 점(.)을 이용하여 폴더들을 구분 함
ex) com.kh.test1

3. 클래스명
-> 실제 소스코드가 들어있는 파일
-> 클래스명은 첫글자가 대문자이며, 구분 단어마다 첫글자는 대문자
ex) SampleMain


---------------------------- 배열 ---------------------------------------

@ 배열
-> 배열은 동일한 타입을 가지는 변수들의 집합

@ 배열의 쓰임
-> 여러개의 변수를 한번에 선언 가능함
-> 같은 형의 변수들을 연속적으로 사용할 수 있음


@ 배열의 선언
-> 배열은 사용하기 위해서는 주소값을 저장하기 위한 레퍼런스 변수가 필요함
	- 자료형 [] 변수이름;
	- 자료형 변수이름 [];
	ex) int [] arr;   또는 int arr []; 
	-> arr같은 변수를 레퍼런스 변수라고 함

@ 배열의 생성
-> 배열은 레퍼런스만으로는 사용할 수 없음
-> 실제 데이터를 저장하기 위한 배열을 만들어야 함
-> 레퍼런스이름 = new 자료형[저장공간개수]
	ex) arr = new int [5];
	5개의 int형으로 이루어진 공간을 가진 배열의 주소를 
	arr의 저장한다는 의미

@ 메모리 구조  (배열을 이해하기 위한 내용)
Stack	-> 일반 변수와 레퍼런스 변수는 Stack 메모리에 생성
Heap	-> New 연산자를 사용하여 만든경우 Heap 메모리에 생성 (동적메모리)
Static	-> 정적(static) 변수나 메소드는 Static 메모리에 생성

ex) 
int [] arr = new int[5]; 
arr는 레퍼런스 변수이므로 Stack 메모리에 생성 됨
new int[5]로 만든 배열은 new 연산자를 사용했으므로 Heap이라는
메모리에 생성 됨


@ 배열의 초기화
int [] arr  = new int[5];  //5개의 int공간을 가지고 있는 배열을 생성
-> 배열은 초기 생성시 초기값을 0을 가지고 있음
 (int 형은 0 / boolean형은 false / char 형은 '' )

int : 정수를 저장하는 데이터형 (그외 short / long 형도 있음)
double : 실수를 저장하는 데이터형 (그외 float 형도 있음)
String : 문자열을 저장하는 데이터형
char : 문자 한글자를 저장하는 데이터형
boolean : 참(true), 거짓(false)을 저장하는 데이터형


@ 배열의 초기값 대입
-> 배열은 중괄호 {} 를 이용하여 초기값을 대입할 수 있음
1. int [] arr = new int[]{1,2,3,4,5};  
2. int [] arr = {1,2,3,4,5};
-> 단, int [] arr = new int[5]{1,2,3,4,5}; 로 코딩할경우 에러 발생


@ 1차원 배열의 접근 방법
-> 배열은 같은 이름의 변수가 연속적인 메모리에 할당되어 있기 때문에
배열이름에 인덱스(요소의 위치)를 이용하여 각 각의 변수를 구별 함
-> 인덱스는 항상 0부터 시작하고, 마지막 인덱스 번호는
배열의 크기보다 항상 1이 작음
ex) 배열의 길이가 5인 경우    0번 인덱스 부터 4번 인덱스까지 존재
int [] arr = new int [3];
arr[0] = 10;	가능
arr[1] = 20;	가능
arr[2] = 30;	가능
arr[3] = 40;	불가능 (코드 에러 / 존재하지 않은 인덱스 번호)

-> 또한 배열은 인덱스를 이용하여 접근하기 때문에 인덱스 안에 변수를 넣어
접근하는 것도 가능함

int [] arr = new int[3];
int index = 0;

arr[index++] = 10;
arr[index++] = 20;
arr[index++] = 30;





---------------------------- Switch 문 ---------------------------------

@ switch 문
-> 변수의 값을 case에서 찾아 명령을 수행하는 제어문
-> 해당하는 값이 없을 경우에는 default의 명령문을 수행

	※ case와 명령문 사이에는 콜론(:)을 사용

switch(변수){
	case 1: 실행문코드1 작성;
		break;
	case 2: 실행문코드2 작성;
		break;
	default : 위에 있는 case가 없을경우 실행 (if문의 else와 같음)
}



---------------------------- 배열 복사 --------------------------------
@ 얕은 복사
-> 참조하고 있는 주소값만을 복사하여 사용 
(같은 배열 데이터를 참조)

@ 깊은 복사
-> 새로운 공간을 생성하여 기존 데이터값을 복사하여 넣음 
 (다른 배열 데이터 참조)



--------------------- 2차원 배열 -----------------------

@ 2차원 배열
-> 2차원 배열은 인덱스를 2개 사용하여 행과 열을 표현하는 것

ex) int [][] arr = new int[3][4];
int [][]arr = new int [행][열];
	※ 가로가 행, 세로가 열


@ 2차원 배열의 초기화

int [][] arr = {1,2,3,4,5,6,7,8}; //불가능함, 행과 열의 길이를 파악할 수 없음
int [][] arr = {{1,2,3},{4,5,6}}; //가능함, 행과 열의 길이를 파악할 수 있음
			//행 2개, 열 3개 짜리가 만들어짐
			// 1,2,3
			// 4,5,6

@ 2차원 배열의 접근
-> 인덱스 2개를 가지고 접근 (마지막 인덱스는 배열 길이의 -1)
int [][] arr = new int[2][3];

arr[0][0] = 1;
arr[0][1] = 2;
arr[0][2] = 3;
arr[1][0] = 4;
arr[1][1] = 5;
arr[1][2] = 6;



--------------------------- 짝수 홀수 구하는 방법---------------------

@ 나머지 연산자
-> 나머지 연산자를 이용하면 짝수/홀수를 구할 수 있음
-> 임의의수 %2 를 했을때, 나머지가 0이 나오면 짝수, 1이 나오면  홀수

ex1) 100%2 의 결과는 0 (짝수)
ex2) 500%2 의 결과는 0 (짝수)
ex3) 103%2 의 결과는 1 (홀수)
ex4) 3%2 의 결과는 1    (홀수)




------------------------------ 메소드 ------------------------------

@ 메소드 (method)
-> 메소드는 타 언어에서는 함수(function)이라고 부름
-> 우리가 기존에 작성하던 공간들도 모두 메소드임 (start 메소드/main메소드)
-> 메소드를 사용하게 됨으로써 기능별 구분을 할 수 있게 됨
-> 재사용하는 코드들은 메소드로 정의함으로써 불필요한 중복 코드들을
줄일 수 있음
-> 메소드명은 해당 기능명을 작성하는게 원칙이고, 낙타표기법을 따름


@ 메소드의 형태

public int add(int a, int b)
{
	int c;
	c = a+b;
	return c;
}
public : 접근제어 지시자 
int : 리턴 데이터 타입
add : 메소드명
(int a, int b) : 매개변수 (parameter)
{ 코드 } : 메소드에서 동작하는 기능
return c : 메소드를 종료하고 값을 가지고 호출된 위치로 돌아감







접근제어지시자  리턴데이터타타입  메소드명 (매개변수)
{
	로직 작성

	리턴 값;
}



@ 메소드의 구분
-> 메소드는 전달인자 (argument)와 반환값 (return value)의 유무에 따라
4가지 유형이 있음

1. 전달인자(O), 반환값(O)
2. 전달인자(O), 반환값(X)
3. 전달인자(X), 반환값(O)
4. 전달인자(X), 반환값(X)


1. 전달인자(O), 반환값(O)
public int test(int a)
{
	return a*a;	
}

2. 전달인자(O), 반환값(X)
public void test(int a)
{
	System.out.println(a);
}

3. 전달인자(X), 반환값(O)
public int test(){
	Scanner sc = new Scanner(System.in);
	int data = sc.nextInt();
	return data;
}

4. 전달인자(X), 반환값(X)
public void start()
{

}



@ 메소드의 메모리 처리
-> 메소드 안에서 생성된 변수들은 해당 메소드에서만 사용 가능



































































































































